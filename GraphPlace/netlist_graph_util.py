from sys import exit
import networkx as nx
from scipy.sparse import csr_matrix
from numba.typed import List

class NetlistGraph:
    # The netlist graph is generated
    # from the netlist_edges generated by VTR
    # VTR is already modified to write out each edge to netlist_edges_criticality file
    # Each edge is in the format of: "<src type> <src> <sink type> <sink> <criticality>"
    # So this function parses the netlist_edges_criticality to extract all the edges and construct the netlist graph
    # To get the netlist_edges, a VTR pass has to run first
    def __init__(self, netlist_edges_criticality_filename):
        # create a netlist graph
        NG = nx.DiGraph()
        with open(netlist_edges_criticality_filename, 'r') as f:
            for line in f:
                source_type, source, sink_type, sink, criticality = line.split()
                NG.add_node(source, type = source_type)
                NG.add_node(sink, type = sink_type)
                NG.add_edge(source, sink, weight = float(criticality))

        # Construct two lists, one for IO, one for CLB
        # Each list contains all blocks compatible for the physical location type
        # e.g. IO_blocks list all blocks which can sit in IO sites
        self.IO_blocks, self.CLB_blocks = List(), List()
        for (idx, node) in enumerate(NG.nodes(data = True)):
            if node[1]['type'] == 'clb':
                # CLB
                self.CLB_blocks.append(idx)
            elif node[1]['type'] == 'io':
                self.IO_blocks.append(idx)
            else:
                print('Error: Unknown logical block type: %s' % (node[1]['type']))
                exit(0)

        if NG.number_of_nodes() == 0:
            print('Error: please run VPR once')
            exit(0)

        self.nodes = list(NG)
        self.NM = nx.adjacency_matrix(NG).todense()
